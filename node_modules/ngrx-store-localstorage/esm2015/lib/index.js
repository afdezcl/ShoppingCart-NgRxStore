import * as deepmerge from 'deepmerge';
const INIT_ACTION = '@ngrx/store/init';
const UPDATE_ACTION = '@ngrx/store/update-reducers';
const detectDate = /(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})/;
// correctly parse dates from local storage
export const dateReviver = (_key, value) => {
    if (typeof value === 'string' && detectDate.test(value)) {
        return new Date(value);
    }
    return value;
};
const dummyReviver = (_key, value) => value;
const ɵ0 = dummyReviver;
const checkIsBrowserEnv = () => {
    return typeof window !== 'undefined';
};
const ɵ1 = checkIsBrowserEnv;
const validateStateKeys = (keys) => {
    return keys.map((key) => {
        let attr = key;
        if (typeof key === 'object') {
            attr = Object.keys(key)[0];
        }
        if (typeof attr !== 'string') {
            throw new TypeError(`localStorageSync Unknown Parameter Type: ` + `Expected type of string, got ${typeof attr}`);
        }
        return key;
    });
};
const ɵ2 = validateStateKeys;
export const rehydrateApplicationState = (keys, storage, storageKeySerializer, restoreDates) => {
    return keys.reduce((acc, curr) => {
        let key = curr;
        let reviver = restoreDates ? dateReviver : dummyReviver;
        let deserialize;
        let decrypt;
        if (typeof key === 'object') {
            key = Object.keys(key)[0];
            // use the custom reviver function
            if (typeof curr[key] === 'function') {
                reviver = curr[key];
            }
            else {
                // use custom reviver function if available
                if (curr[key].reviver) {
                    reviver = curr[key].reviver;
                }
                // use custom serialize function if available
                if (curr[key].deserialize) {
                    deserialize = curr[key].deserialize;
                }
            }
            // Ensure that encrypt and decrypt functions are both present
            if (curr[key].encrypt && curr[key].decrypt) {
                if (typeof curr[key].encrypt === 'function' && typeof curr[key].decrypt === 'function') {
                    decrypt = curr[key].decrypt;
                }
                else {
                    console.error(`Either encrypt or decrypt is not a function on '${curr[key]}' key object.`);
                }
            }
            else if (curr[key].encrypt || curr[key].decrypt) {
                // Let know that one of the encryption functions is not provided
                console.error(`Either encrypt or decrypt function is not present on '${curr[key]}' key object.`);
            }
        }
        if (storage !== undefined) {
            let stateSlice = storage.getItem(storageKeySerializer(key));
            if (stateSlice) {
                // Use provided decrypt function
                if (decrypt) {
                    stateSlice = decrypt(stateSlice);
                }
                const isObjectRegex = new RegExp('{|\\[');
                let raw = stateSlice;
                if (stateSlice === 'null' || isObjectRegex.test(stateSlice.charAt(0))) {
                    raw = JSON.parse(stateSlice, reviver);
                }
                return Object.assign({}, acc, {
                    [key]: deserialize ? deserialize(raw) : raw,
                });
            }
        }
        return acc;
    }, {});
};
// Recursively traverse all properties of the existing slice as defined by the `filter` argument,
// and output the new object with extraneous properties removed.
function createStateSlice(existingSlice, filter) {
    return filter.reduce((memo, attr) => {
        if (typeof attr === 'string' || typeof attr === 'number') {
            const value = existingSlice === null || existingSlice === void 0 ? void 0 : existingSlice[attr];
            if (value !== undefined) {
                memo[attr] = value;
            }
        }
        else {
            for (const key in attr) {
                if (Object.prototype.hasOwnProperty.call(attr, key)) {
                    const element = attr[key];
                    memo[key] = createStateSlice(existingSlice[key], element);
                }
            }
        }
        return memo;
    }, {});
}
export const syncStateUpdate = (state, keys, storage, storageKeySerializer, removeOnUndefined, syncCondition) => {
    if (syncCondition) {
        try {
            if (syncCondition(state) !== true) {
                return;
            }
        }
        catch (e) {
            // Treat TypeError as do not sync
            if (e instanceof TypeError) {
                return;
            }
            throw e;
        }
    }
    keys.forEach((key) => {
        let stateSlice = state[key];
        let replacer;
        let space;
        let encrypt;
        if (typeof key === 'object') {
            let name = Object.keys(key)[0];
            stateSlice = state[name];
            if (typeof stateSlice !== 'undefined' && key[name]) {
                // use serialize function if specified.
                if (key[name].serialize) {
                    stateSlice = key[name].serialize(stateSlice);
                }
                else {
                    // if serialize function is not specified filter on fields if an array has been provided.
                    let filter;
                    if (key[name].reduce) {
                        filter = key[name];
                    }
                    else if (key[name].filter) {
                        filter = key[name].filter;
                    }
                    if (filter) {
                        stateSlice = createStateSlice(stateSlice, filter);
                    }
                    // Check if encrypt and decrypt are present, also checked at this#rehydrateApplicationState()
                    if (key[name].encrypt && key[name].decrypt) {
                        if (typeof key[name].encrypt === 'function') {
                            encrypt = key[name].encrypt;
                        }
                    }
                    else if (key[name].encrypt || key[name].decrypt) {
                        // If one of those is not present, then let know that one is missing
                        console.error(`Either encrypt or decrypt function is not present on '${key[name]}' key object.`);
                    }
                }
                /*
          Replacer and space arguments to pass to JSON.stringify.
          If these fields don't exist, undefined will be passed.
        */
                replacer = key[name].replacer;
                space = key[name].space;
            }
            key = name;
        }
        if (typeof stateSlice !== 'undefined' && storage !== undefined) {
            try {
                if (encrypt) {
                    // ensure that a string message is passed
                    stateSlice = encrypt(typeof stateSlice === 'string' ? stateSlice : JSON.stringify(stateSlice, replacer, space));
                }
                storage.setItem(storageKeySerializer(key), typeof stateSlice === 'string' ? stateSlice : JSON.stringify(stateSlice, replacer, space));
            }
            catch (e) {
                console.warn('Unable to save state to localStorage:', e);
            }
        }
        else if (typeof stateSlice === 'undefined' && removeOnUndefined) {
            try {
                storage.removeItem(storageKeySerializer(key));
            }
            catch (e) {
                console.warn(`Exception on removing/cleaning undefined '${key}' state`, e);
            }
        }
    });
};
// Default merge strategy is a full deep merge.
export const defaultMergeReducer = (state, rehydratedState, action) => {
    if ((action.type === INIT_ACTION || action.type === UPDATE_ACTION) && rehydratedState) {
        const overwriteMerge = (destinationArray, sourceArray, options) => sourceArray;
        const options = {
            arrayMerge: overwriteMerge,
        };
        state = deepmerge(state, rehydratedState, options);
    }
    return state;
};
export const localStorageSync = (config) => (reducer) => {
    if ((config.storage === undefined && !config.checkStorageAvailability) ||
        (config.checkStorageAvailability && checkIsBrowserEnv())) {
        config.storage = localStorage || window.localStorage;
    }
    if (config.storageKeySerializer === undefined) {
        config.storageKeySerializer = (key) => key;
    }
    if (config.restoreDates === undefined) {
        config.restoreDates = true;
    }
    // Use default merge reducer.
    let mergeReducer = config.mergeReducer;
    if (mergeReducer === undefined || typeof mergeReducer !== 'function') {
        mergeReducer = defaultMergeReducer;
    }
    const stateKeys = validateStateKeys(config.keys);
    const rehydratedState = config.rehydrate
        ? rehydrateApplicationState(stateKeys, config.storage, config.storageKeySerializer, config.restoreDates)
        : undefined;
    return function (state, action) {
        let nextState;
        // If state arrives undefined, we need to let it through the supplied reducer
        // in order to get a complete state as defined by user
        if (action.type === INIT_ACTION && !state) {
            nextState = reducer(state, action);
        }
        else {
            nextState = Object.assign({}, state);
        }
        // Merge the store state with the rehydrated state using
        // either a user-defined reducer or the default.
        nextState = mergeReducer(nextState, rehydratedState, action);
        nextState = reducer(nextState, action);
        if (action.type !== INIT_ACTION) {
            syncStateUpdate(nextState, stateKeys, config.storage, config.storageKeySerializer, config.removeOnUndefined, config.syncCondition);
        }
        return nextState;
    };
};
export { ɵ0, ɵ1, ɵ2 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sS0FBSyxTQUFTLE1BQU0sV0FBVyxDQUFDO0FBRXZDLE1BQU0sV0FBVyxHQUFHLGtCQUFrQixDQUFDO0FBQ3ZDLE1BQU0sYUFBYSxHQUFHLDZCQUE2QixDQUFDO0FBQ3BELE1BQU0sVUFBVSxHQUFHLGlEQUFpRCxDQUFDO0FBRXJFLDJDQUEyQztBQUMzQyxNQUFNLENBQUMsTUFBTSxXQUFXLEdBQUcsQ0FBQyxJQUFZLEVBQUUsS0FBVSxFQUFFLEVBQUU7SUFDcEQsSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLElBQUksVUFBVSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRTtRQUNyRCxPQUFPLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0tBQzFCO0lBQ0QsT0FBTyxLQUFLLENBQUM7QUFDakIsQ0FBQyxDQUFDO0FBRUYsTUFBTSxZQUFZLEdBQUcsQ0FBQyxJQUFZLEVBQUUsS0FBVSxFQUFFLEVBQUUsQ0FBQyxLQUFLLENBQUM7O0FBRXpELE1BQU0saUJBQWlCLEdBQUcsR0FBRyxFQUFFO0lBQzNCLE9BQU8sT0FBTyxNQUFNLEtBQUssV0FBVyxDQUFDO0FBQ3pDLENBQUMsQ0FBQzs7QUFFRixNQUFNLGlCQUFpQixHQUFHLENBQUMsSUFBVSxFQUFFLEVBQUU7SUFDckMsT0FBUSxJQUFjLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUU7UUFDL0IsSUFBSSxJQUFJLEdBQUcsR0FBRyxDQUFDO1FBRWYsSUFBSSxPQUFPLEdBQUcsS0FBSyxRQUFRLEVBQUU7WUFDekIsSUFBSSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDOUI7UUFFRCxJQUFJLE9BQU8sSUFBSSxLQUFLLFFBQVEsRUFBRTtZQUMxQixNQUFNLElBQUksU0FBUyxDQUNmLDJDQUEyQyxHQUFHLGdDQUFnQyxPQUFPLElBQUksRUFBRSxDQUM5RixDQUFDO1NBQ0w7UUFDRCxPQUFPLEdBQUcsQ0FBQztJQUNmLENBQUMsQ0FBQyxDQUFDO0FBQ1AsQ0FBQyxDQUFDOztBQUVGLE1BQU0sQ0FBQyxNQUFNLHlCQUF5QixHQUFHLENBQ3JDLElBQVUsRUFDVixPQUFnQixFQUNoQixvQkFBNkMsRUFDN0MsWUFBcUIsRUFDdkIsRUFBRTtJQUNBLE9BQVEsSUFBYyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsRUFBRTtRQUN4QyxJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUM7UUFDZixJQUFJLE9BQU8sR0FBRyxZQUFZLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDO1FBQ3hELElBQUksV0FBa0MsQ0FBQztRQUN2QyxJQUFJLE9BQWlDLENBQUM7UUFFdEMsSUFBSSxPQUFPLEdBQUcsS0FBSyxRQUFRLEVBQUU7WUFDekIsR0FBRyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDMUIsa0NBQWtDO1lBQ2xDLElBQUksT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssVUFBVSxFQUFFO2dCQUNqQyxPQUFPLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO2FBQ3ZCO2lCQUFNO2dCQUNILDJDQUEyQztnQkFDM0MsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsT0FBTyxFQUFFO29CQUNuQixPQUFPLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQztpQkFDL0I7Z0JBQ0QsNkNBQTZDO2dCQUM3QyxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxXQUFXLEVBQUU7b0JBQ3ZCLFdBQVcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsV0FBVyxDQUFDO2lCQUN2QzthQUNKO1lBRUQsNkRBQTZEO1lBQzdELElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsT0FBTyxFQUFFO2dCQUN4QyxJQUFJLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sS0FBSyxVQUFVLElBQUksT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsT0FBTyxLQUFLLFVBQVUsRUFBRTtvQkFDcEYsT0FBTyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUM7aUJBQy9CO3FCQUFNO29CQUNILE9BQU8sQ0FBQyxLQUFLLENBQUMsbURBQW1ELElBQUksQ0FBQyxHQUFHLENBQUMsZUFBZSxDQUFDLENBQUM7aUJBQzlGO2FBQ0o7aUJBQU0sSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsT0FBTyxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLEVBQUU7Z0JBQy9DLGdFQUFnRTtnQkFDaEUsT0FBTyxDQUFDLEtBQUssQ0FBQyx5REFBeUQsSUFBSSxDQUFDLEdBQUcsQ0FBQyxlQUFlLENBQUMsQ0FBQzthQUNwRztTQUNKO1FBQ0QsSUFBSSxPQUFPLEtBQUssU0FBUyxFQUFFO1lBQ3ZCLElBQUksVUFBVSxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsb0JBQW9CLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUM1RCxJQUFJLFVBQVUsRUFBRTtnQkFDWixnQ0FBZ0M7Z0JBQ2hDLElBQUksT0FBTyxFQUFFO29CQUNULFVBQVUsR0FBRyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUM7aUJBQ3BDO2dCQUVELE1BQU0sYUFBYSxHQUFHLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDO2dCQUMxQyxJQUFJLEdBQUcsR0FBRyxVQUFVLENBQUM7Z0JBRXJCLElBQUksVUFBVSxLQUFLLE1BQU0sSUFBSSxhQUFhLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTtvQkFDbkUsR0FBRyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxFQUFFLE9BQU8sQ0FBQyxDQUFDO2lCQUN6QztnQkFFRCxPQUFPLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLEdBQUcsRUFBRTtvQkFDMUIsQ0FBQyxHQUFHLENBQUMsRUFBRSxXQUFXLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRztpQkFDOUMsQ0FBQyxDQUFDO2FBQ047U0FDSjtRQUNELE9BQU8sR0FBRyxDQUFDO0lBQ2YsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBQ1gsQ0FBQyxDQUFDO0FBRUYsaUdBQWlHO0FBQ2pHLGdFQUFnRTtBQUNoRSxTQUFTLGdCQUFnQixDQUFDLGFBQWtCLEVBQUUsTUFBd0Q7SUFDbEcsT0FBTyxNQUFNLENBQUMsTUFBTSxDQUNoQixDQUFDLElBQTRDLEVBQUUsSUFBa0QsRUFBRSxFQUFFO1FBQ2pHLElBQUksT0FBTyxJQUFJLEtBQUssUUFBUSxJQUFJLE9BQU8sSUFBSSxLQUFLLFFBQVEsRUFBRTtZQUN0RCxNQUFNLEtBQUssR0FBRyxhQUFhLGFBQWIsYUFBYSx1QkFBYixhQUFhLENBQUcsSUFBSSxDQUFDLENBQUM7WUFDcEMsSUFBSSxLQUFLLEtBQUssU0FBUyxFQUFFO2dCQUNyQixJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDO2FBQ3RCO1NBQ0o7YUFBTTtZQUNILEtBQUssTUFBTSxHQUFHLElBQUksSUFBSSxFQUFFO2dCQUNwQixJQUFJLE1BQU0sQ0FBQyxTQUFTLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFDLEVBQUU7b0JBQ2pELE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztvQkFDMUIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLGdCQUFnQixDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQztpQkFDN0Q7YUFDSjtTQUNKO1FBQ0QsT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBQyxFQUNELEVBQUUsQ0FDTCxDQUFDO0FBQ04sQ0FBQztBQUVELE1BQU0sQ0FBQyxNQUFNLGVBQWUsR0FBRyxDQUMzQixLQUFVLEVBQ1YsSUFBVSxFQUNWLE9BQWdCLEVBQ2hCLG9CQUFzRCxFQUN0RCxpQkFBMEIsRUFDMUIsYUFBbUMsRUFDckMsRUFBRTtJQUNBLElBQUksYUFBYSxFQUFFO1FBQ2YsSUFBSTtZQUNBLElBQUksYUFBYSxDQUFDLEtBQUssQ0FBQyxLQUFLLElBQUksRUFBRTtnQkFDL0IsT0FBTzthQUNWO1NBQ0o7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUNSLGlDQUFpQztZQUNqQyxJQUFJLENBQUMsWUFBWSxTQUFTLEVBQUU7Z0JBQ3hCLE9BQU87YUFDVjtZQUNELE1BQU0sQ0FBQyxDQUFDO1NBQ1g7S0FDSjtJQUVELElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUE2RSxFQUFRLEVBQUU7UUFDakcsSUFBSSxVQUFVLEdBQUcsS0FBSyxDQUFDLEdBQWEsQ0FBQyxDQUFDO1FBQ3RDLElBQUksUUFBUSxDQUFDO1FBQ2IsSUFBSSxLQUFzQixDQUFDO1FBQzNCLElBQUksT0FBTyxDQUFDO1FBRVosSUFBSSxPQUFPLEdBQUcsS0FBSyxRQUFRLEVBQUU7WUFDekIsSUFBSSxJQUFJLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUMvQixVQUFVLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBRXpCLElBQUksT0FBTyxVQUFVLEtBQUssV0FBVyxJQUFJLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRTtnQkFDaEQsdUNBQXVDO2dCQUN2QyxJQUFJLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxTQUFTLEVBQUU7b0JBQ3JCLFVBQVUsR0FBRyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxDQUFDO2lCQUNoRDtxQkFBTTtvQkFDSCx5RkFBeUY7b0JBQ3pGLElBQUksTUFBMEIsQ0FBQztvQkFDL0IsSUFBSSxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxFQUFFO3dCQUNsQixNQUFNLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO3FCQUN0Qjt5QkFBTSxJQUFJLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLEVBQUU7d0JBQ3pCLE1BQU0sR0FBRyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDO3FCQUM3QjtvQkFDRCxJQUFJLE1BQU0sRUFBRTt3QkFDUixVQUFVLEdBQUcsZ0JBQWdCLENBQUMsVUFBVSxFQUFFLE1BQU0sQ0FBQyxDQUFDO3FCQUNyRDtvQkFFRCw2RkFBNkY7b0JBQzdGLElBQUksR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sSUFBSSxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxFQUFFO3dCQUN4QyxJQUFJLE9BQU8sR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sS0FBSyxVQUFVLEVBQUU7NEJBQ3pDLE9BQU8sR0FBRyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDO3lCQUMvQjtxQkFDSjt5QkFBTSxJQUFJLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFPLElBQUksR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sRUFBRTt3QkFDL0Msb0VBQW9FO3dCQUNwRSxPQUFPLENBQUMsS0FBSyxDQUNULHlEQUF5RCxHQUFHLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FDcEYsQ0FBQztxQkFDTDtpQkFDSjtnQkFFRDs7O1VBR047Z0JBQ00sUUFBUSxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxRQUFRLENBQUM7Z0JBQzlCLEtBQUssR0FBRyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsS0FBSyxDQUFDO2FBQzNCO1lBRUQsR0FBRyxHQUFHLElBQUksQ0FBQztTQUNkO1FBRUQsSUFBSSxPQUFPLFVBQVUsS0FBSyxXQUFXLElBQUksT0FBTyxLQUFLLFNBQVMsRUFBRTtZQUM1RCxJQUFJO2dCQUNBLElBQUksT0FBTyxFQUFFO29CQUNULHlDQUF5QztvQkFDekMsVUFBVSxHQUFHLE9BQU8sQ0FDaEIsT0FBTyxVQUFVLEtBQUssUUFBUSxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsVUFBVSxFQUFFLFFBQVEsRUFBRSxLQUFLLENBQUMsQ0FDNUYsQ0FBQztpQkFDTDtnQkFDRCxPQUFPLENBQUMsT0FBTyxDQUNYLG9CQUFvQixDQUFDLEdBQWEsQ0FBQyxFQUNuQyxPQUFPLFVBQVUsS0FBSyxRQUFRLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxVQUFVLEVBQUUsUUFBUSxFQUFFLEtBQUssQ0FBQyxDQUM1RixDQUFDO2FBQ0w7WUFBQyxPQUFPLENBQUMsRUFBRTtnQkFDUixPQUFPLENBQUMsSUFBSSxDQUFDLHVDQUF1QyxFQUFFLENBQUMsQ0FBQyxDQUFDO2FBQzVEO1NBQ0o7YUFBTSxJQUFJLE9BQU8sVUFBVSxLQUFLLFdBQVcsSUFBSSxpQkFBaUIsRUFBRTtZQUMvRCxJQUFJO2dCQUNBLE9BQU8sQ0FBQyxVQUFVLENBQUMsb0JBQW9CLENBQUMsR0FBYSxDQUFDLENBQUMsQ0FBQzthQUMzRDtZQUFDLE9BQU8sQ0FBQyxFQUFFO2dCQUNSLE9BQU8sQ0FBQyxJQUFJLENBQUMsNkNBQTZDLEdBQUcsU0FBUyxFQUFFLENBQUMsQ0FBQyxDQUFDO2FBQzlFO1NBQ0o7SUFDTCxDQUFDLENBQUMsQ0FBQztBQUNQLENBQUMsQ0FBQztBQUVGLCtDQUErQztBQUMvQyxNQUFNLENBQUMsTUFBTSxtQkFBbUIsR0FBRyxDQUFDLEtBQVUsRUFBRSxlQUFvQixFQUFFLE1BQVcsRUFBRSxFQUFFO0lBQ2pGLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxLQUFLLFdBQVcsSUFBSSxNQUFNLENBQUMsSUFBSSxLQUFLLGFBQWEsQ0FBQyxJQUFJLGVBQWUsRUFBRTtRQUNuRixNQUFNLGNBQWMsR0FBRyxDQUFDLGdCQUFxQixFQUFFLFdBQWdCLEVBQUUsT0FBWSxFQUFFLEVBQUUsQ0FBQyxXQUFXLENBQUM7UUFDOUYsTUFBTSxPQUFPLEdBQXNCO1lBQy9CLFVBQVUsRUFBRSxjQUFjO1NBQzdCLENBQUM7UUFFRixLQUFLLEdBQUcsU0FBUyxDQUFDLEtBQUssRUFBRSxlQUFlLEVBQUUsT0FBTyxDQUFDLENBQUM7S0FDdEQ7SUFFRCxPQUFPLEtBQUssQ0FBQztBQUNqQixDQUFDLENBQUM7QUFFRixNQUFNLENBQUMsTUFBTSxnQkFBZ0IsR0FBRyxDQUFDLE1BQTBCLEVBQUUsRUFBRSxDQUFDLENBQUMsT0FBWSxFQUFFLEVBQUU7SUFDN0UsSUFDSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLEtBQUssU0FBUyxJQUFJLENBQUMsTUFBTSxDQUFDLHdCQUF3QixDQUFDO1FBQ2xFLENBQUMsTUFBTSxDQUFDLHdCQUF3QixJQUFJLGlCQUFpQixFQUFFLENBQUMsRUFDMUQ7UUFDRSxNQUFNLENBQUMsT0FBTyxHQUFHLFlBQVksSUFBSSxNQUFNLENBQUMsWUFBWSxDQUFDO0tBQ3hEO0lBRUQsSUFBSSxNQUFNLENBQUMsb0JBQW9CLEtBQUssU0FBUyxFQUFFO1FBQzNDLE1BQU0sQ0FBQyxvQkFBb0IsR0FBRyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDO0tBQzlDO0lBRUQsSUFBSSxNQUFNLENBQUMsWUFBWSxLQUFLLFNBQVMsRUFBRTtRQUNuQyxNQUFNLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQztLQUM5QjtJQUVELDZCQUE2QjtJQUM3QixJQUFJLFlBQVksR0FBRyxNQUFNLENBQUMsWUFBWSxDQUFDO0lBRXZDLElBQUksWUFBWSxLQUFLLFNBQVMsSUFBSSxPQUFPLFlBQVksS0FBSyxVQUFVLEVBQUU7UUFDbEUsWUFBWSxHQUFHLG1CQUFtQixDQUFDO0tBQ3RDO0lBRUQsTUFBTSxTQUFTLEdBQUcsaUJBQWlCLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ2pELE1BQU0sZUFBZSxHQUFHLE1BQU0sQ0FBQyxTQUFTO1FBQ3BDLENBQUMsQ0FBQyx5QkFBeUIsQ0FBQyxTQUFTLEVBQUUsTUFBTSxDQUFDLE9BQU8sRUFBRSxNQUFNLENBQUMsb0JBQW9CLEVBQUUsTUFBTSxDQUFDLFlBQVksQ0FBQztRQUN4RyxDQUFDLENBQUMsU0FBUyxDQUFDO0lBRWhCLE9BQU8sVUFBVSxLQUFVLEVBQUUsTUFBVztRQUNwQyxJQUFJLFNBQWMsQ0FBQztRQUVuQiw2RUFBNkU7UUFDN0Usc0RBQXNEO1FBQ3RELElBQUksTUFBTSxDQUFDLElBQUksS0FBSyxXQUFXLElBQUksQ0FBQyxLQUFLLEVBQUU7WUFDdkMsU0FBUyxHQUFHLE9BQU8sQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUM7U0FDdEM7YUFBTTtZQUNILFNBQVMscUJBQVEsS0FBSyxDQUFFLENBQUM7U0FDNUI7UUFFRCx3REFBd0Q7UUFDeEQsZ0RBQWdEO1FBQ2hELFNBQVMsR0FBRyxZQUFZLENBQUMsU0FBUyxFQUFFLGVBQWUsRUFBRSxNQUFNLENBQUMsQ0FBQztRQUU3RCxTQUFTLEdBQUcsT0FBTyxDQUFDLFNBQVMsRUFBRSxNQUFNLENBQUMsQ0FBQztRQUV2QyxJQUFJLE1BQU0sQ0FBQyxJQUFJLEtBQUssV0FBVyxFQUFFO1lBQzdCLGVBQWUsQ0FDWCxTQUFTLEVBQ1QsU0FBUyxFQUNULE1BQU0sQ0FBQyxPQUFPLEVBQ2QsTUFBTSxDQUFDLG9CQUFvQixFQUMzQixNQUFNLENBQUMsaUJBQWlCLEVBQ3hCLE1BQU0sQ0FBQyxhQUFhLENBQ3ZCLENBQUM7U0FDTDtRQUVELE9BQU8sU0FBUyxDQUFDO0lBQ3JCLENBQUMsQ0FBQztBQUNOLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGRlZXBtZXJnZSBmcm9tICdkZWVwbWVyZ2UnO1xuXG5jb25zdCBJTklUX0FDVElPTiA9ICdAbmdyeC9zdG9yZS9pbml0JztcbmNvbnN0IFVQREFURV9BQ1RJT04gPSAnQG5ncngvc3RvcmUvdXBkYXRlLXJlZHVjZXJzJztcbmNvbnN0IGRldGVjdERhdGUgPSAvKFxcZHs0fSktKFxcZHsyfSktKFxcZHsyfSlUKFxcZHsyfSk6KFxcZHsyfSk6KFxcZHsyfSkvO1xuXG4vLyBjb3JyZWN0bHkgcGFyc2UgZGF0ZXMgZnJvbSBsb2NhbCBzdG9yYWdlXG5leHBvcnQgY29uc3QgZGF0ZVJldml2ZXIgPSAoX2tleTogc3RyaW5nLCB2YWx1ZTogYW55KSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgZGV0ZWN0RGF0ZS50ZXN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG5jb25zdCBkdW1teVJldml2ZXIgPSAoX2tleTogc3RyaW5nLCB2YWx1ZTogYW55KSA9PiB2YWx1ZTtcblxuY29uc3QgY2hlY2tJc0Jyb3dzZXJFbnYgPSAoKSA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xufTtcblxuY29uc3QgdmFsaWRhdGVTdGF0ZUtleXMgPSAoa2V5czogS2V5cykgPT4ge1xuICAgIHJldHVybiAoa2V5cyBhcyBhbnlbXSkubWFwKChrZXkpID0+IHtcbiAgICAgICAgbGV0IGF0dHIgPSBrZXk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBhdHRyID0gT2JqZWN0LmtleXMoa2V5KVswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYXR0ciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgYGxvY2FsU3RvcmFnZVN5bmMgVW5rbm93biBQYXJhbWV0ZXIgVHlwZTogYCArIGBFeHBlY3RlZCB0eXBlIG9mIHN0cmluZywgZ290ICR7dHlwZW9mIGF0dHJ9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5O1xuICAgIH0pO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlaHlkcmF0ZUFwcGxpY2F0aW9uU3RhdGUgPSAoXG4gICAga2V5czogS2V5cyxcbiAgICBzdG9yYWdlOiBTdG9yYWdlLFxuICAgIHN0b3JhZ2VLZXlTZXJpYWxpemVyOiAoa2V5OiBzdHJpbmcpID0+IHN0cmluZyxcbiAgICByZXN0b3JlRGF0ZXM6IGJvb2xlYW5cbikgPT4ge1xuICAgIHJldHVybiAoa2V5cyBhcyBhbnlbXSkucmVkdWNlKChhY2MsIGN1cnIpID0+IHtcbiAgICAgICAgbGV0IGtleSA9IGN1cnI7XG4gICAgICAgIGxldCByZXZpdmVyID0gcmVzdG9yZURhdGVzID8gZGF0ZVJldml2ZXIgOiBkdW1teVJldml2ZXI7XG4gICAgICAgIGxldCBkZXNlcmlhbGl6ZTogKGFyZzA6IHN0cmluZykgPT4gYW55O1xuICAgICAgICBsZXQgZGVjcnlwdDogKGFyZzA6IHN0cmluZykgPT4gc3RyaW5nO1xuXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAga2V5ID0gT2JqZWN0LmtleXMoa2V5KVswXTtcbiAgICAgICAgICAgIC8vIHVzZSB0aGUgY3VzdG9tIHJldml2ZXIgZnVuY3Rpb25cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3VycltrZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV2aXZlciA9IGN1cnJba2V5XTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdXNlIGN1c3RvbSByZXZpdmVyIGZ1bmN0aW9uIGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgIGlmIChjdXJyW2tleV0ucmV2aXZlcikge1xuICAgICAgICAgICAgICAgICAgICByZXZpdmVyID0gY3VycltrZXldLnJldml2ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHVzZSBjdXN0b20gc2VyaWFsaXplIGZ1bmN0aW9uIGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgIGlmIChjdXJyW2tleV0uZGVzZXJpYWxpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzZXJpYWxpemUgPSBjdXJyW2tleV0uZGVzZXJpYWxpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBFbnN1cmUgdGhhdCBlbmNyeXB0IGFuZCBkZWNyeXB0IGZ1bmN0aW9ucyBhcmUgYm90aCBwcmVzZW50XG4gICAgICAgICAgICBpZiAoY3VycltrZXldLmVuY3J5cHQgJiYgY3VycltrZXldLmRlY3J5cHQpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGN1cnJba2V5XS5lbmNyeXB0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBjdXJyW2tleV0uZGVjcnlwdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBkZWNyeXB0ID0gY3VycltrZXldLmRlY3J5cHQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRWl0aGVyIGVuY3J5cHQgb3IgZGVjcnlwdCBpcyBub3QgYSBmdW5jdGlvbiBvbiAnJHtjdXJyW2tleV19JyBrZXkgb2JqZWN0LmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycltrZXldLmVuY3J5cHQgfHwgY3VycltrZXldLmRlY3J5cHQpIHtcbiAgICAgICAgICAgICAgICAvLyBMZXQga25vdyB0aGF0IG9uZSBvZiB0aGUgZW5jcnlwdGlvbiBmdW5jdGlvbnMgaXMgbm90IHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRWl0aGVyIGVuY3J5cHQgb3IgZGVjcnlwdCBmdW5jdGlvbiBpcyBub3QgcHJlc2VudCBvbiAnJHtjdXJyW2tleV19JyBrZXkgb2JqZWN0LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdG9yYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBzdGF0ZVNsaWNlID0gc3RvcmFnZS5nZXRJdGVtKHN0b3JhZ2VLZXlTZXJpYWxpemVyKGtleSkpO1xuICAgICAgICAgICAgaWYgKHN0YXRlU2xpY2UpIHtcbiAgICAgICAgICAgICAgICAvLyBVc2UgcHJvdmlkZWQgZGVjcnlwdCBmdW5jdGlvblxuICAgICAgICAgICAgICAgIGlmIChkZWNyeXB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlU2xpY2UgPSBkZWNyeXB0KHN0YXRlU2xpY2UpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IGlzT2JqZWN0UmVnZXggPSBuZXcgUmVnRXhwKCd7fFxcXFxbJyk7XG4gICAgICAgICAgICAgICAgbGV0IHJhdyA9IHN0YXRlU2xpY2U7XG5cbiAgICAgICAgICAgICAgICBpZiAoc3RhdGVTbGljZSA9PT0gJ251bGwnIHx8IGlzT2JqZWN0UmVnZXgudGVzdChzdGF0ZVNsaWNlLmNoYXJBdCgwKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmF3ID0gSlNPTi5wYXJzZShzdGF0ZVNsaWNlLCByZXZpdmVyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgYWNjLCB7XG4gICAgICAgICAgICAgICAgICAgIFtrZXldOiBkZXNlcmlhbGl6ZSA/IGRlc2VyaWFsaXplKHJhdykgOiByYXcsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG59O1xuXG4vLyBSZWN1cnNpdmVseSB0cmF2ZXJzZSBhbGwgcHJvcGVydGllcyBvZiB0aGUgZXhpc3Rpbmcgc2xpY2UgYXMgZGVmaW5lZCBieSB0aGUgYGZpbHRlcmAgYXJndW1lbnQsXG4vLyBhbmQgb3V0cHV0IHRoZSBuZXcgb2JqZWN0IHdpdGggZXh0cmFuZW91cyBwcm9wZXJ0aWVzIHJlbW92ZWQuXG5mdW5jdGlvbiBjcmVhdGVTdGF0ZVNsaWNlKGV4aXN0aW5nU2xpY2U6IGFueSwgZmlsdGVyOiAoc3RyaW5nIHwgbnVtYmVyIHwgS2V5Q29uZmlndXJhdGlvbiB8IE9wdGlvbnMpW10pIHtcbiAgICByZXR1cm4gZmlsdGVyLnJlZHVjZShcbiAgICAgICAgKG1lbW86IHsgW3g6IHN0cmluZ106IGFueTsgW3g6IG51bWJlcl06IGFueSB9LCBhdHRyOiBzdHJpbmcgfCBudW1iZXIgfCBLZXlDb25maWd1cmF0aW9uIHwgT3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhdHRyID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgYXR0ciA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGV4aXN0aW5nU2xpY2U/LlthdHRyXTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBtZW1vW2F0dHJdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXR0ciwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGF0dHJba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lbW9ba2V5XSA9IGNyZWF0ZVN0YXRlU2xpY2UoZXhpc3RpbmdTbGljZVtrZXldLCBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZW1vO1xuICAgICAgICB9LFxuICAgICAgICB7fVxuICAgICk7XG59XG5cbmV4cG9ydCBjb25zdCBzeW5jU3RhdGVVcGRhdGUgPSAoXG4gICAgc3RhdGU6IGFueSxcbiAgICBrZXlzOiBLZXlzLFxuICAgIHN0b3JhZ2U6IFN0b3JhZ2UsXG4gICAgc3RvcmFnZUtleVNlcmlhbGl6ZXI6IChrZXk6IHN0cmluZyB8IG51bWJlcikgPT4gc3RyaW5nLFxuICAgIHJlbW92ZU9uVW5kZWZpbmVkOiBib29sZWFuLFxuICAgIHN5bmNDb25kaXRpb24/OiAoc3RhdGU6IGFueSkgPT4gYW55XG4pID0+IHtcbiAgICBpZiAoc3luY0NvbmRpdGlvbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHN5bmNDb25kaXRpb24oc3RhdGUpICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBUcmVhdCBUeXBlRXJyb3IgYXMgZG8gbm90IHN5bmNcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgVHlwZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGtleXMuZm9yRWFjaCgoa2V5OiBzdHJpbmcgfCBLZXlDb25maWd1cmF0aW9uIHwgT3B0aW9ucyB8ICgoa2V5OiBzdHJpbmcsIHZhbHVlOiBhbnkpID0+IGFueSkpOiB2b2lkID0+IHtcbiAgICAgICAgbGV0IHN0YXRlU2xpY2UgPSBzdGF0ZVtrZXkgYXMgc3RyaW5nXTtcbiAgICAgICAgbGV0IHJlcGxhY2VyO1xuICAgICAgICBsZXQgc3BhY2U6IHN0cmluZyB8IG51bWJlcjtcbiAgICAgICAgbGV0IGVuY3J5cHQ7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBsZXQgbmFtZSA9IE9iamVjdC5rZXlzKGtleSlbMF07XG4gICAgICAgICAgICBzdGF0ZVNsaWNlID0gc3RhdGVbbmFtZV07XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RhdGVTbGljZSAhPT0gJ3VuZGVmaW5lZCcgJiYga2V5W25hbWVdKSB7XG4gICAgICAgICAgICAgICAgLy8gdXNlIHNlcmlhbGl6ZSBmdW5jdGlvbiBpZiBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgICAgaWYgKGtleVtuYW1lXS5zZXJpYWxpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVTbGljZSA9IGtleVtuYW1lXS5zZXJpYWxpemUoc3RhdGVTbGljZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgc2VyaWFsaXplIGZ1bmN0aW9uIGlzIG5vdCBzcGVjaWZpZWQgZmlsdGVyIG9uIGZpZWxkcyBpZiBhbiBhcnJheSBoYXMgYmVlbiBwcm92aWRlZC5cbiAgICAgICAgICAgICAgICAgICAgbGV0IGZpbHRlcjogS2V5Q29uZmlndXJhdGlvbltdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5W25hbWVdLnJlZHVjZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyID0ga2V5W25hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtleVtuYW1lXS5maWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlciA9IGtleVtuYW1lXS5maWx0ZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVTbGljZSA9IGNyZWF0ZVN0YXRlU2xpY2Uoc3RhdGVTbGljZSwgZmlsdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGVuY3J5cHQgYW5kIGRlY3J5cHQgYXJlIHByZXNlbnQsIGFsc28gY2hlY2tlZCBhdCB0aGlzI3JlaHlkcmF0ZUFwcGxpY2F0aW9uU3RhdGUoKVxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5W25hbWVdLmVuY3J5cHQgJiYga2V5W25hbWVdLmRlY3J5cHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5W25hbWVdLmVuY3J5cHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNyeXB0ID0ga2V5W25hbWVdLmVuY3J5cHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5W25hbWVdLmVuY3J5cHQgfHwga2V5W25hbWVdLmRlY3J5cHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIG9uZSBvZiB0aG9zZSBpcyBub3QgcHJlc2VudCwgdGhlbiBsZXQga25vdyB0aGF0IG9uZSBpcyBtaXNzaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBFaXRoZXIgZW5jcnlwdCBvciBkZWNyeXB0IGZ1bmN0aW9uIGlzIG5vdCBwcmVzZW50IG9uICcke2tleVtuYW1lXX0nIGtleSBvYmplY3QuYFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgUmVwbGFjZXIgYW5kIHNwYWNlIGFyZ3VtZW50cyB0byBwYXNzIHRvIEpTT04uc3RyaW5naWZ5LlxuICAgICAgICAgIElmIHRoZXNlIGZpZWxkcyBkb24ndCBleGlzdCwgdW5kZWZpbmVkIHdpbGwgYmUgcGFzc2VkLlxuICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHJlcGxhY2VyID0ga2V5W25hbWVdLnJlcGxhY2VyO1xuICAgICAgICAgICAgICAgIHNwYWNlID0ga2V5W25hbWVdLnNwYWNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBrZXkgPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZVNsaWNlICE9PSAndW5kZWZpbmVkJyAmJiBzdG9yYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGVuY3J5cHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5zdXJlIHRoYXQgYSBzdHJpbmcgbWVzc2FnZSBpcyBwYXNzZWRcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVTbGljZSA9IGVuY3J5cHQoXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2Ygc3RhdGVTbGljZSA9PT0gJ3N0cmluZycgPyBzdGF0ZVNsaWNlIDogSlNPTi5zdHJpbmdpZnkoc3RhdGVTbGljZSwgcmVwbGFjZXIsIHNwYWNlKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdG9yYWdlLnNldEl0ZW0oXG4gICAgICAgICAgICAgICAgICAgIHN0b3JhZ2VLZXlTZXJpYWxpemVyKGtleSBhcyBzdHJpbmcpLFxuICAgICAgICAgICAgICAgICAgICB0eXBlb2Ygc3RhdGVTbGljZSA9PT0gJ3N0cmluZycgPyBzdGF0ZVNsaWNlIDogSlNPTi5zdHJpbmdpZnkoc3RhdGVTbGljZSwgcmVwbGFjZXIsIHNwYWNlKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdVbmFibGUgdG8gc2F2ZSBzdGF0ZSB0byBsb2NhbFN0b3JhZ2U6JywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHN0YXRlU2xpY2UgPT09ICd1bmRlZmluZWQnICYmIHJlbW92ZU9uVW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHN0b3JhZ2UucmVtb3ZlSXRlbShzdG9yYWdlS2V5U2VyaWFsaXplcihrZXkgYXMgc3RyaW5nKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBFeGNlcHRpb24gb24gcmVtb3ZpbmcvY2xlYW5pbmcgdW5kZWZpbmVkICcke2tleX0nIHN0YXRlYCwgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbi8vIERlZmF1bHQgbWVyZ2Ugc3RyYXRlZ3kgaXMgYSBmdWxsIGRlZXAgbWVyZ2UuXG5leHBvcnQgY29uc3QgZGVmYXVsdE1lcmdlUmVkdWNlciA9IChzdGF0ZTogYW55LCByZWh5ZHJhdGVkU3RhdGU6IGFueSwgYWN0aW9uOiBhbnkpID0+IHtcbiAgICBpZiAoKGFjdGlvbi50eXBlID09PSBJTklUX0FDVElPTiB8fCBhY3Rpb24udHlwZSA9PT0gVVBEQVRFX0FDVElPTikgJiYgcmVoeWRyYXRlZFN0YXRlKSB7XG4gICAgICAgIGNvbnN0IG92ZXJ3cml0ZU1lcmdlID0gKGRlc3RpbmF0aW9uQXJyYXk6IGFueSwgc291cmNlQXJyYXk6IGFueSwgb3B0aW9uczogYW55KSA9PiBzb3VyY2VBcnJheTtcbiAgICAgICAgY29uc3Qgb3B0aW9uczogZGVlcG1lcmdlLk9wdGlvbnMgPSB7XG4gICAgICAgICAgICBhcnJheU1lcmdlOiBvdmVyd3JpdGVNZXJnZSxcbiAgICAgICAgfTtcblxuICAgICAgICBzdGF0ZSA9IGRlZXBtZXJnZShzdGF0ZSwgcmVoeWRyYXRlZFN0YXRlLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhdGU7XG59O1xuXG5leHBvcnQgY29uc3QgbG9jYWxTdG9yYWdlU3luYyA9IChjb25maWc6IExvY2FsU3RvcmFnZUNvbmZpZykgPT4gKHJlZHVjZXI6IGFueSkgPT4ge1xuICAgIGlmIChcbiAgICAgICAgKGNvbmZpZy5zdG9yYWdlID09PSB1bmRlZmluZWQgJiYgIWNvbmZpZy5jaGVja1N0b3JhZ2VBdmFpbGFiaWxpdHkpIHx8XG4gICAgICAgIChjb25maWcuY2hlY2tTdG9yYWdlQXZhaWxhYmlsaXR5ICYmIGNoZWNrSXNCcm93c2VyRW52KCkpXG4gICAgKSB7XG4gICAgICAgIGNvbmZpZy5zdG9yYWdlID0gbG9jYWxTdG9yYWdlIHx8IHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5zdG9yYWdlS2V5U2VyaWFsaXplciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbmZpZy5zdG9yYWdlS2V5U2VyaWFsaXplciA9IChrZXkpID0+IGtleTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLnJlc3RvcmVEYXRlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbmZpZy5yZXN0b3JlRGF0ZXMgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIFVzZSBkZWZhdWx0IG1lcmdlIHJlZHVjZXIuXG4gICAgbGV0IG1lcmdlUmVkdWNlciA9IGNvbmZpZy5tZXJnZVJlZHVjZXI7XG5cbiAgICBpZiAobWVyZ2VSZWR1Y2VyID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIG1lcmdlUmVkdWNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBtZXJnZVJlZHVjZXIgPSBkZWZhdWx0TWVyZ2VSZWR1Y2VyO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXRlS2V5cyA9IHZhbGlkYXRlU3RhdGVLZXlzKGNvbmZpZy5rZXlzKTtcbiAgICBjb25zdCByZWh5ZHJhdGVkU3RhdGUgPSBjb25maWcucmVoeWRyYXRlXG4gICAgICAgID8gcmVoeWRyYXRlQXBwbGljYXRpb25TdGF0ZShzdGF0ZUtleXMsIGNvbmZpZy5zdG9yYWdlLCBjb25maWcuc3RvcmFnZUtleVNlcmlhbGl6ZXIsIGNvbmZpZy5yZXN0b3JlRGF0ZXMpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZTogYW55LCBhY3Rpb246IGFueSkge1xuICAgICAgICBsZXQgbmV4dFN0YXRlOiBhbnk7XG5cbiAgICAgICAgLy8gSWYgc3RhdGUgYXJyaXZlcyB1bmRlZmluZWQsIHdlIG5lZWQgdG8gbGV0IGl0IHRocm91Z2ggdGhlIHN1cHBsaWVkIHJlZHVjZXJcbiAgICAgICAgLy8gaW4gb3JkZXIgdG8gZ2V0IGEgY29tcGxldGUgc3RhdGUgYXMgZGVmaW5lZCBieSB1c2VyXG4gICAgICAgIGlmIChhY3Rpb24udHlwZSA9PT0gSU5JVF9BQ1RJT04gJiYgIXN0YXRlKSB7XG4gICAgICAgICAgICBuZXh0U3RhdGUgPSByZWR1Y2VyKHN0YXRlLCBhY3Rpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV4dFN0YXRlID0geyAuLi5zdGF0ZSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWVyZ2UgdGhlIHN0b3JlIHN0YXRlIHdpdGggdGhlIHJlaHlkcmF0ZWQgc3RhdGUgdXNpbmdcbiAgICAgICAgLy8gZWl0aGVyIGEgdXNlci1kZWZpbmVkIHJlZHVjZXIgb3IgdGhlIGRlZmF1bHQuXG4gICAgICAgIG5leHRTdGF0ZSA9IG1lcmdlUmVkdWNlcihuZXh0U3RhdGUsIHJlaHlkcmF0ZWRTdGF0ZSwgYWN0aW9uKTtcblxuICAgICAgICBuZXh0U3RhdGUgPSByZWR1Y2VyKG5leHRTdGF0ZSwgYWN0aW9uKTtcblxuICAgICAgICBpZiAoYWN0aW9uLnR5cGUgIT09IElOSVRfQUNUSU9OKSB7XG4gICAgICAgICAgICBzeW5jU3RhdGVVcGRhdGUoXG4gICAgICAgICAgICAgICAgbmV4dFN0YXRlLFxuICAgICAgICAgICAgICAgIHN0YXRlS2V5cyxcbiAgICAgICAgICAgICAgICBjb25maWcuc3RvcmFnZSxcbiAgICAgICAgICAgICAgICBjb25maWcuc3RvcmFnZUtleVNlcmlhbGl6ZXIsXG4gICAgICAgICAgICAgICAgY29uZmlnLnJlbW92ZU9uVW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGNvbmZpZy5zeW5jQ29uZGl0aW9uXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5leHRTdGF0ZTtcbiAgICB9O1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBMb2NhbFN0b3JhZ2VDb25maWcge1xuICAgIGtleXM6IEtleXM7XG4gICAgcmVoeWRyYXRlPzogYm9vbGVhbjtcbiAgICBzdG9yYWdlPzogU3RvcmFnZTtcbiAgICByZW1vdmVPblVuZGVmaW5lZD86IGJvb2xlYW47XG4gICAgcmVzdG9yZURhdGVzPzogYm9vbGVhbjtcbiAgICBzdG9yYWdlS2V5U2VyaWFsaXplcj86IChrZXk6IHN0cmluZykgPT4gc3RyaW5nO1xuICAgIHN5bmNDb25kaXRpb24/OiAoc3RhdGU6IGFueSkgPT4gYW55O1xuICAgIGNoZWNrU3RvcmFnZUF2YWlsYWJpbGl0eT86IGJvb2xlYW47XG4gICAgbWVyZ2VSZWR1Y2VyPzogKHN0YXRlOiBhbnksIHJlaHlkcmF0ZWRTdGF0ZTogYW55LCBhY3Rpb246IGFueSkgPT4gYW55O1xufVxuXG5pbnRlcmZhY2UgS2V5Q29uZmlndXJhdGlvbiB7XG4gICAgW2tleTogc3RyaW5nXTogc3RyaW5nW10gfCBudW1iZXJbXSB8IEtleUNvbmZpZ3VyYXRpb25bXSB8IE9wdGlvbnMgfCAoKGtleTogc3RyaW5nLCB2YWx1ZTogYW55KSA9PiBhbnkpO1xufVxuXG5pbnRlcmZhY2UgT3B0aW9ucyB7XG4gICAgc2VyaWFsaXplPzogKHN0YXRlOiBhbnkpID0+IGFueTtcbiAgICBkZXNlcmlhbGl6ZT86IChzdGF0ZTogYW55KSA9PiBhbnk7XG4gICAgcmV2aXZlcj86IChrZXk6IHN0cmluZywgdmFsdWU6IGFueSkgPT4gYW55O1xuICAgIHJlcGxhY2VyPzogKChrZXk6IHN0cmluZywgdmFsdWU6IGFueSkgPT4gYW55KSB8IHN0cmluZ1tdO1xuICAgIGVuY3J5cHQ/OiAobWVzc2FnZTogc3RyaW5nKSA9PiBzdHJpbmc7XG4gICAgZGVjcnlwdD86IChtZXNzYWdlOiBzdHJpbmcpID0+IHN0cmluZztcbiAgICBmaWx0ZXI/OiBzdHJpbmdbXTtcbiAgICBzcGFjZT86IHN0cmluZyB8IG51bWJlcjtcbn1cblxuZXhwb3J0IHR5cGUgS2V5cyA9IChLZXlDb25maWd1cmF0aW9uIHwgT3B0aW9uc3wgc3RyaW5nKVtdO1xuIl19